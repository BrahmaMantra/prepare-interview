- 内存图可以从BIOS或UEFI固件中查询，但只能在启动过程的早期查询。由于这个原因，它必须由引导程序提供，因为内核没有办法在以后检索到它。
- **memory_map**字段包含了可用物理内存的概览。它告诉我们的内核，系统中有多少物理内存可用，哪些内存区域被保留给设备，如VGA硬件。
- **physical_memory_offset**告诉我们物理内存映射的虚拟起始地址。通过把这个偏移量加到物理地址上，我们得到相应的虚拟地址。这使得我们可以从我们的内核中访问任意的物理内存。
- **FrameAllocator**在内核开发中非常重要，因为它负责管理物理内存帧的分配和释放。以下是 FrameAllocator 的主要用途：
    1. 物理内存管理：FrameAllocator 提供了一种机制来跟踪哪些物理内存帧是空闲的，哪些是已分配的。这对于操作系统内核来说是至关重要的，因为内核需要知道哪些内存可以安全地使用。

    2. 内存分页：在实现虚拟内存和分页机制时，FrameAllocator 用于分配物理内存帧，并将这些帧映射到虚拟地址空间。通过这种方式，内核可以创建和管理页表，从而实现虚拟内存。

    3. 堆分配器支持：在实现堆分配器时，FrameAllocator 可以用于分配大块的物理内存，这些内存块然后可以被堆分配器进一步划分和管理。堆分配器通常需要从 FrameAllocator 获取内存帧，以便在需要时扩展堆。

    4. 设备内存管理：某些设备可能需要直接访问物理内存。FrameAllocator 可以用于分配这些设备所需的物理内存帧，并确保这些帧不会被其他部分的内核或用户程序使用。
- 这个物理内存偏移可以通过在Cargo.toml中添加一个[package.metadata.bootloader]表并设置physical-memory-offset = "0x0000f00000000000"（或任何其他值）来定制。然而，请注意，如果bootloader遇到物理地址值开始与偏移量以外的空间重叠，也就是说，它以前会映射到其他早期的物理地址的区域，就会出现恐慌。所以一般来说，这个值越高（>1 TiB）越好。
- 个人观点：虚拟内存的bit数比物理内存多不是没有理由的
- 局部local变量存储在调用栈上，只在周围函数返回之前有效。静态static变量存储在固定的内存位置，并且在程序的整个生命周期内始终存在
### 堆内存分配
堆支持通过两个函数在运行时进行**动态内存分配**，分别是 **allocate** 和 **deallocate**。其工作方式如下：
- allocate 函数返回一个指定大小的空闲内存块，可以用来存储变量，通过write写入对应值。这个变量将一直存在，直到通过调用deallocate
- deallocate 函数传递变量的引用来释放它。这俩函数很少主动调用，很多都抽象到标准库里隐式调用。
- 最重要的类型是 Box，它是一个堆分配值的抽象。它提供了一个 Box::new 构造函数，该函数接受一个值，调用 allocate 分配该值的大小，然后将该值移动到堆上新分配的槽中。为了再次释放堆内存，Box 类型实现了 Drop trait，当它超出作用域时调用 deallocate。
- 这种模式有一个奇怪的名字，叫做资源获取即初始化（Resource Acquisition Is Initialization，简称RAII）。它起源于C++，用于实现一个类似的抽象类型 std::unique_ptr。
- 在no_std的环境下，我们需要手动编写一个全局的allocator来保证堆的分配，不然我们怎么知道堆怎么映射到page呢？
```rust
#[global_allocator]
static ALLOCATOR: LockedHeap = LockedHeap::empty();
```

### 内存管理之有无RC？[blogos](https://os.phil-opp.com/heap-allocation/#allocations-in-rust)
- 众所周知，java py go都有gc，意思就是程序员从不手动调用deallocate，而是程序定期扫描。
- Rust 采用了不同的方法来解决这个问题：它使用一种称为所有权的概念，能够在编译时检查动态内存操作的正确性。因此，不需要垃圾回收来避免上述漏洞，这意味着没有性能开销。这种方法的另一个优点是程序员仍然可以像使用 C 或 C++ 一样对动态内存的使用进行细粒度控制（说人话就是，在编译时而非运行时就检查，避免了内存操作的正确性，没有GC，与C中的手写内存管理相比，没有运行时的性能开销）

- 初始化堆分配器后，才能使用动态分配内存或动态生命周期的数据类型，如Vec，String，Rc等。