### 1.new和malloc的区别？如果混用会如何？malloc(0)返回什么？
- 区别：new是运算符，malloc是库函数;返回值不一样，malloc返回的是**void类型指针**
可以混用: new与malloc混用，malloc**不会调用构造函数**，也不会进行类中成员初始化，只是开辟了一片指定大小的空间；
但是可以**手动调用**构造函数和析构函数来达成混用，流程如下:
~~~ cpp
int main()
{
    A *pa = (A*)malloc(sizeof(A));   //malloc
    pa = new(pa)A();                  //placement new
    cout << pa->m_a;                    //成员已初始化
    pa->~A();                          //析构
    free(pa);                           //释放
}       
~~~ 
malloc(0)返回一个非空的地址。
- 分配内存的位置：malloc从**堆**上动态分配内存，new是从自由存储区为对象动态分配内存（**取决于operator new**的实现，可以为堆还可以是静态存储区）

New申请内存的步骤：调用operator new函数，分配一块足够大，且原始的，未命名的内存空间来存储特定类型的对象。运行相应的构造函数来构造对象，并为其传入初值，返回一个指向该对象的指针。

Delete：先调用对象的析构函数，再调用operator delete函数释放内存空间

### 2介绍一下socket中的多路复用，及其他们的优缺点
#### select: 
优点：
- 跨平台：select 函数在几乎所有的操作系统上都可用。
- 简单易用：API 简单，易于理解和使用。

缺点：
- 文件描述符限制：select 的文件描述符数量有限制，通常为 1024。
- 性能问题：每次调用 select 都需要将文件描述符集合从用户态复制到内核态，随着文件描述符数量增加，性能下降。
- 线性扫描：select 需要线性扫描所有文件描述符，效率较低。

#### poll
优点：
- 无文件描述符限制：poll 没有文件描述符数量的限制。（在我目前看来就这一个）
- 灵活性：支持更多的事件类型。
缺点：
- 性能问题：每次调用 poll 都需要将文件描述符集合从用户态复制到内核态，随着文件描述符数量增加，性能下降。
- 线性扫描：poll 需要线性扫描所有文件描述符，效率较低。

#### epoll
优点：
- 高效：epoll 使用**事件通知机制**，避免了每次调用都需要线性扫描文件描述符集合。
- 无文件描述符限制：epoll 没有文件描述符数量的限制。
- 边缘触发和水平触发：支持边缘触发（Edge-Triggered）和水平触发（Level-Triggered）模式。
  
缺点：
- Linux 专有：epoll 仅在 Linux 上可用，不具有跨平台性。
- 复杂性：API 相对复杂，需要更多的代码来管理。

### 3虚函数相关
#### 虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的
在C++中，虚函数的实现原理基于两个关键概念：虚函数表（VT）和虚函数指针（VTP）

- 虚函数表：每个包含虚函数的类都会生成一个虚函数表，其中存储着该类中所有虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。(放在代码段)

- 虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针指向该对象对应的虚函数表，从而让程序能够动态的调用虚函数。（放在对象实例，但是不会占sizeof的内存大小）

当一个基类指针或引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。

在编译阶段生成，虚函数和普通函数一样存放在代码段，只是它的指针又存放在了虚表之中。
#### 父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？
- 构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找vptr，但此时vptr还没有完成初始化，导致无法构造对象。
- 析构函数可以且经常为虚函数：当我们使用父类指针指向子类时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成内存泄漏。

#### 类中static函数是否能声明为虚函数？
- 不能，因为类中的static函数是所有类实例化对象所共有的，没有this指针，而虚函数依靠vptr和vtable来处理，vptr是一个指针，在类中的构造函数中生成，并且只能通过this指针访问，对于静态成员函数来说，他没有this指针，无法访问vptr，因此static函数无法声明为虚函数

#### 哪些函数不能被声明为虚函数？
- 构造函数，内联函数（内联函数有实体，在编译时展开，没有this指针），静态成员函数，友元函数（C++不支持友元函数的继承），非类成员函数

### 4 shared_ptr线程安全吗？
- 引用计数的线程安全：std::shared_ptr 的引用计数是线程安全的。也就是说，在多个线程中同时增加或减少引用计数是安全的。

- 对象访问的线程安全：std::shared_ptr 本身并不保证所管理对象的线程安全性。如果多个线程同时访问或修改共享对象，需要自行确保对象的线程安全性（例如使用互斥锁）。

### 5 move的底层是怎么实现的
- Move的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义，从实现原理上讲基本等同一个强制类型转换。
- 优点：可以将左值变成右值而避免拷贝构造，将对象的状态所有权从一个对象转移到另一个对象，只是转移，没有内存搬迁或者内存拷贝。

### 6.动态链接和静态链接的区别，动态链接的原理是什么？
- 区别：他们的最大区别就是在于链接的时机不同，静态链接是在形成可执行程序前，而动态链接的进行则是程序执行时。

- 静态库：就是将库中的代码包含到自己的程序之中，每个程序链接静态库后，都会包含一份独立的代码，当程序运行起来时，所有这些重复的代码都需要占用独立的存储空间，显然很浪费计算机资源。

- 动态库：不会将代码直接复制到自己程序中，只会留下调用接口，程序运行时再去将动态库加载到内存中，所有程序只会共享这一份动态库，因此动态库也被称为共享库。

- 动态链接原理：是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件

### 7.说一下内联函数及其优缺点
- 内联函数是在编译期将函数体内嵌到程序之中，以此来节省函数调用的开销。
- 优点：是节省了函数调用的开销，让程序运行更加快速。
- 缺点：是如果函数体过长，频繁使用内联函数会导致代码编译膨胀问题。不能递归执行

### 8.编译器是如何实现重载的？
在编译时，编译器如果遇到了函数，就会在符号表里面命名一个符号来存放函数的地址，如果函数的**使用在定义之前编译**，无法在符号表中找到对应函数地址，则先标记为“？”（暂时未知），在全部编译结束后的链接过程将“？”在符号表里找到并替代为相应的函数地址，如果函数的**定义在使用之前编译**，则可以直接在符号表里找到对应函数地址直接使用，而在**C语言中**的符号表是以**函数名为符号**来存储函数地址，函数名相同的重载函数的地址应该不同，于是符号表中存在两个同符号的函数地址，在查找使用时会存在歧义和冲突。而C++符号表中的符号不是以函数名命名的，称为**函数名修饰规则**，虽然函数名相同，但是函数参数等其他属性不同，取的符号也不同，所以不会产生查询歧义的问题，使得函数可以重载。

### 9.什么是函数调用约定？
函数调用约定就是对函数调用的一个**约束和规定**，描述了函数参数是怎么传递和由谁清除堆栈的。它决定了，函数参数传递的方式（是否采用寄存器传递参数，采用哪个寄存器传递参数，参数压栈的顺序等），函数调用结束后栈指针由谁恢复（被调用的函数恢复还是调用者恢复），函数修饰名的产生方法。
- __stdcall：是standardcall的缩写，是C++的标准调用方式，规则如下：所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是this指针。被调用函数**自动清理堆栈**，返回值在EAX。函数修饰名约定：VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上“**@”和参数的字节数**。

- __cdecl：是C DECLaration的缩写（declaration，声明），表示C语言的默认函数调用方法，规定如下：所有参数从右往左依次入栈，所有参数由调用者清除，称为**手动清栈**。返回值在EAX中。函数修饰名约定：VC将函数编译后会在函数名前面加上下划线前缀，由于由调用者清理栈，所以允许可变参数函数存在。

- __fastcall：是快速调用约定，通过寄存器来传送参数，规则如下：用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍然自右向左压栈传送。被调用函数在返回前清理传送参数的内存栈，返回值在EAX中。函数修饰名约定：VC将函数编译后会在函数名前面加上“@”前缀，在函数名后加上“@”和参数的字节数。

- __thiscall：是唯一一个不能明确指明的函数修饰符，thiscall只能用于处理C++类成员函数的调用，同时thiscall也是C++成员函数缺省的调用约定，由于成员函数调用还有一个this指针，因此必须特殊处理，规定如下：采用栈传递参数，参数从右向左入栈，如果参数个数确定，this指针通过TCX传递给被调用者，如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。对参数个数不确定的，调用者清理堆栈，否则由被调函数清理堆栈，__thiscal不是关键字，程序员不能使用l

- __pascal：与__stdcall一样，在VC中已经被废弃

### 10.回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？
- 回调函数是指使用者自己定义一个函数，实现这个函数的程序内容，然后别人把这个函数（入口地址）**作为参数**传入别人的函数中，由别人的函数在运行时来调用的函数，简单说就是放发生某种事件时，系统或其他函数将会自动调用你定义的一段函数。可以**把调用者和被调用者分开**。调用者不关心谁是被调用者，所以它只需要知道的，只是一个存在某种特定类型原型，某些限制条件的被调用函数。
- 优点：
1. 可以让实现方根据回调方的多种形态进行不同的处理和操作
2. 可以让实现方，根据自己的需要定制回调方的不同形态
3. 可以将耗时的操作隐藏在回调方，不影响实现方其他信息的展示。
4. 让代码的逻辑更加集中，更加易读。
- 缺点：
1. 回调函数过多会导致代码难以维护
2. 回调函数容易造成资源竞争：如果回调函数中有共享资源访问，容易出现资源争抢，导致程序出错
3. 代码可读性差，可能会破坏代码的结构和可读性
- 本质：是将函数当作参数使用，目的是为了使程序更加普适。

### 11.什么是this指针，为什么存在this指针？
- this 指针是 C++ 中的一个特殊指针，它指向调用成员函数的对象本身。this 指针在类的非静态成员函数中隐式可用，用于访问和操作对象的成员变量和成员函数。

用途
- 访问成员变量和成员函数：通过 this 指针，可以访问对象的成员变量和成员函数。
- 返回对象本身：在成员函数中，可以通过返回 *this 来返回对象本身，支持链式调用。
- 解决命名冲突：当成员变量和函数参数同名时，可以使用 this 指针来区分成员变量和函数参数。

### 12.什么是重载、重写、隐藏？
- 重载：函数名相同，函数参数不同，两个函数在同一作用域
- 重写：两个函数分别在子类和父类中，函数名，返回值，参数均相同，函数必须为虚函数
- 隐藏：在继承关系中，子类实现了一个和父类名字名字一样的函数。这样子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关。


### 13. const int* p与int * const p区别
- const int* p：指向常量整数的指针，指针指向的值不能被修改，但指针本身可以指向其他地址。
~~~ cpp
const int* p;
int a = 10;
int b = 20;
p = &a;  // 合法
*p = 30; // 非法，不能修改指向的值
p = &b;  // 合法，可以改变指针指向
~~~
- int* const p：常量指针，指向整数的指针，指针本身不能改变指向，但指针指向的值可以被修改。
~~~ cpp
int* const p = &a;
int a = 10;
int b = 20;
p = &b;  // 非法，不能改变指针指向
*p = 30; // 合法，可以修改指向的值
~~~

### 14.指针与引用的区别
- 指针：存储变量地址的变量，可以为空（NULL），可以指向不同的变量，是一个**实体**
- 变量的**别名**，必须在定义时初始化，不能改变引用的对象。
- 指针和引用主要有以下区别：
    - 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
    - 引用初始化后不能被改变，指针可以改变所指的对象。
    - 不存在指向空值的引用，但是存在指向空值的指针。

### 15.内联函数和宏定义的区别
内联函数（inline function）和宏定义（macro definition）都是用于提高程序运行效率的技术，但它们在实现方式、使用场景和优缺点上有显著的区别。
- 内联函数：内联函数是通过inline关键字定义的函数，建议编译器在**调用该函数时**将其**展开**为内联代码，而不是进行常规的函数调用。
- 宏定义：宏定义是通过**预处理**指令#define定义的代码片段，预处理器在**编译前**会将所有宏替换为相应的代码。
- 优缺点
| 特性           | 内联函数（inline function）                  | 宏定义（macro definition）                  |
|----------------|---------------------------------------------|--------------------------------------------|
| 类型安全       | 是                                           | 否                                         |
| 调试友好       | 是                                           | 否                                         |
| 作用域控制     | 是                                           | 否                                         |
| 支持复杂逻辑   | 是                                           | 否                                         |
| 编译器建议     | 是（编译器可能忽略）                         | 否（预处理器强制替换）                     |
| 代码膨胀       | 可能（函数体积大且多次调用）                 | 可能（宏体积大且多次调用）                 |
| 简单替换       | 否                                           | 是                                         |
| 无类型限制     | 否                                           | 是                                         |
| 潜在错误       | 少                                           | 多（如缺少括号导致的优先级问题）           |


### 16.数组传参
在 C++ 中，buf 和 &buf 在传递给函数时有不同的含义，具体取决于函数的参数类型。以下是它们的区别：

buf
buf 是一个字符数组，当它被传递给函数时，会被隐式转换为指向数组第一个元素的指针，即 char* 类型。
~~~ cpp
char buf[1024];
some_function(buf); // buf 被转换为 char*
~~~
&buf
&buf 是一个指向整个数组的指针，其类型是 char (*)[1024]，即指向一个包含 1024 个字符的数组的指针。
``` cpp
char buf[1024];
some_function(&buf); // &buf 的类型是 char (*)[1024]
```
示例
以下是一个示例，展示了 buf 和 &buf 的区别：
``` cpp
#include <iostream>
#include <cstring>

void print_size(char* ptr) {
    std::cout << "Size of char* ptr: " << sizeof(ptr) << std::endl;
}

void print_size(char (*ptr)[1024]) {
    std::cout << "Size of char (*ptr)[1024]: " << sizeof(*ptr) << std::endl;
}

int main() {
    char buf[1024];
    bzero(buf, sizeof(buf));

    print_size(buf);   // 传递 char* 类型
    print_size(&buf);  // 传递 char (*)[1024] 类型

    return 0;
}
```
输出如下：
``` bash
dragonos@DragonOS-A18-HP:~/note/prepare-interview$ ./test 
Size of char* ptr: 8
Size of char (*ptr)[1024]: 1024
```

### 17.enum和enum class
在 C++ 中，`enum` 和 `enum class` 都用于定义枚举类型，但它们有一些重要的区别。以下是它们的主要区别：

### `enum`

`enum` 是传统的枚举类型，来自 C 语言。它的特点如下：

1. **作用域**：`enum` 定义的枚举成员在定义它们的作用域内是全局的。
2. **隐式转换**：`enum` 枚举成员可以隐式转换为整数类型。
3. **类型安全**：`enum` 不提供类型安全，不同的枚举类型的成员可以互相比较。

#### 示例

```cpp
#include <iostream>

enum Color {
    RED,
    GREEN,
    BLUE
};

enum TrafficLight {
    RED_LIGHT,
    GREEN_LIGHT,
    YELLOW_LIGHT
};

int main() {
    Color color = RED;
    TrafficLight light = RED_LIGHT;

    // 隐式转换为整数
    int colorValue = color;
    std::cout << "Color value: " << colorValue << std::endl;

    // 不同枚举类型的成员可以比较
    if (color == light) {
        std::cout << "Color and TrafficLight are equal!" << std::endl;
    } else {
        std::cout << "Color and TrafficLight are not equal!" << std::endl;
    }

    return 0;
}
```

### `enum class`

`enum class` 是 C++11 引入的强类型枚举类型。它的特点如下：

1. **作用域**：`enum class` 定义的枚举成员在枚举类型的作用域内。
2. **隐式转换**：`enum class` 枚举成员不能隐式转换为整数类型，需要显式转换。
3. **类型安全**：`enum class` 提供类型安全，不同的枚举类型的成员不能互相比较。

#### 示例

```cpp
#include <iostream>

enum class Color {
    RED,
    GREEN,
    BLUE
};

enum class TrafficLight {
    RED,
    GREEN,
    YELLOW
};

int main() {
    Color color = Color::RED;
    TrafficLight light = TrafficLight::RED;

    // 不能隐式转换为整数，需要显式转换
    int colorValue = static_cast<int>(color);
    std::cout << "Color value: " << colorValue << std::endl;

    // 不同枚举类型的成员不能比较
    // if (color == light) { // 错误：不同枚举类型不能比较
    //     std::cout << "Color and TrafficLight are equal!" << std::endl;
    // } else {
    //     std::cout << "Color and TrafficLight are not equal!" << std::endl;
    // }

    return 0;
}
```

### 总结

- **作用域**：
  - `enum`：枚举成员在定义它们的作用域内是全局的。
  - `enum class`：枚举成员在枚举类型的作用域内。

- **隐式转换**：
  - `enum`：枚举成员可以隐式转换为整数类型。
  - `enum class`：枚举成员不能隐式转换为整数类型，需要显式转换。

- **类型安全**：
  - `enum`：不提供类型安全，不同的枚举类型的成员可以互相比较。
  - `enum class`：提供类型安全，不同的枚举类型的成员不能互相比较。

使用 `enum class` 可以提高代码的类型安全性和可读性，避免意外的类型转换和比较。

### 奇怪的问题

#### ssize_t write_bytes = (sockfd, buf, sizeof(buf));
正如你所看，我们缺少了read或者write，但是居然可以过编译，那么write_bytes返回的到底是啥？
~~~ cpp
dragonos@DragonOS-A18-HP:~/user_fz/cpp-web-server/bin$ ./client 
a
write_bytes is 1024
~~~
事实证明，逗号表达式会依次计算每个子表达式的值，并返回最后一个子表达式的值。在这种情况下，(sockfd, buf, sizeof(buf)) 的返回值是 sizeof(buf)，即 1024。