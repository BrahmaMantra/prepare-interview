1. redis能存哪些类型#

string == Map<String，String>

map    == Map<String，Map<String>>

list   == Map<String ， List<String>>

set    == Map<String，Set<String>>

zset   == Map<String，ZSet<String>>


2、redis为什么这么快？ 高并发如何处理的？#

高并发的原因：

1.redis是基于内存的，内存的读写速度非常快；

2.redis是单线程的，省去了很多上下文切换线程的时间；

3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。

为什么Redis是单线程的：

官方答案： 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。

不需要各种锁的性能消耗

Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除

一个对象。这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。

总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。

CPU消耗：

采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。

但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？

可以考虑多起几个Redis进程，Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。

4.Redis的内存淘汰策略有哪些#

Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。
- 我就知道一个LRU，还有在过期时间的key中挑选

### 缓存雪崩怎么办
一、预防策略
1. 差异化过期时间

    原理：避免大量 Key 同时过期。

    实现：在设置缓存过期时间时，添加随机值（例如：基础过期时间 + 随机 1-5 分钟）。

    代码示例：
    java
    复制

    // 设置过期时间 = 基础时间 + 随机偏移量
    int baseExpire = 3600; // 基础时间 1 小时
    int randomExpire = baseExpire + new Random().nextInt(300); // 随机增加 0-5 分钟
    redis.set(key, value, randomExpire);

2. 热点数据永不过期

    原理：对核心热点数据不设置过期时间，改为通过异步任务定期更新。

    实现：

        缓存不设置 TTL（过期时间）。

        启动后台线程，定期检测并更新缓存（如使用定时任务或消息队列）。

3. 多级缓存架构

    原理：构建多层缓存（如本地缓存 + 分布式缓存），降低单层缓存失效的影响。

    实现：

        第一层：本地缓存（如 Caffeine、Guava Cache），设置短过期时间。

        第二层：分布式缓存（如 Redis），设置较长过期时间。

        本地缓存失效后，从分布式缓存读取；若分布式缓存也失效，通过分布式锁控制仅一个线程回源数据库。

4. 熔断与降级

    原理：当数据库压力过大时，暂时拒绝部分请求，保护系统整体可用性。

    实现：

        使用熔断框架（如 Hystrix、Sentinel），监控数据库的 QPS 或响应时间。

        触发阈值后，直接返回降级内容（如默认值、错误页），避免数据库崩溃。

二、应急措施
1. 服务高可用

    Redis 集群部署：使用 Redis Cluster 或主从复制 + Sentinel，避免单点故障。

    异地多活：跨机房部署缓存服务，确保区域性故障时自动切换。

2. 限流机制

    原理：控制请求并发量，减轻数据库压力。

    实现：

        网关层限流（如 Nginx 的 limit_req 模块）。

        服务层限流（如 Redis + Lua 实现令牌桶算法）。

3. 快速缓存重建

    原理：缓存失效后，快速重建减少空窗期。

    实现：

        使用分布式锁（如 Redis 的 SETNX），仅允许一个线程回源数据库，其他线程等待。

        提前预热缓存：在业务低峰期主动更新即将过期的 Key。

三、总结方案组合

    核心场景：差异化过期时间 + 熔断降级 + 多级缓存。

    高并发场景：多级缓存 + 分布式锁 + 限流。

    容灾场景：Redis 集群 + 异地多活 + 熔断降级。

### 缓存穿透怎么办
- 缓存穿透是指查询不存在的数据，导致请求直接打到数据库，可能引发数据库压力过大甚至崩溃。
- 从外到内，可行的解决方案：
1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
2. 布隆过滤器（Bloom Filter）
- 原理：使用布隆过滤器判断 Key 是否存在，拦截无效请求。  
- 实现：
    - 将所有可能存在的 Key 预先加载到布隆过滤器中。
    - 查询缓存前，先通过布隆过滤器判断 Key 是否存在：
        - 如果不存在，直接返回空结果。
        - 如果存在，继续查询缓存或数据库。
- 优点：内存占用少，效率高。（因为bloom filter是把key用不同hash算法到不同数组，每个key的映射完后只有1bit）
- 缺点：存在一定的误判率（可通过调整参数降低）。

3. 缓存空值

    原理：对查询结果为空的 Key 也进行缓存，避免重复查询数据库。

    实现：

        查询数据库为空时，缓存一个特殊值（如 NULL 或 EMPTY）。

        设置较短的过期时间（如 5 分钟），避免长期占用缓存空间。
### 缓存击穿
缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

解决方案

    设置热点数据永远不过期。

    加互斥锁，互斥锁。

### 缓存预热

缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

解决方案

    直接写个缓存刷新页面，上线时手工操作一下；

    数据量不大，可以在项目启动的时候自动进行加载；

    定时刷新缓存；

## 如何保证数据库和缓存双写一致性
你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？

一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。

串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是先更新数据库，然后再删除缓存。
| 问题场景 | 描述 | 解决 |
| --- | --- | --- |
| 先写缓存，再写数据库，缓存写成功，数据库写失败 | 缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读 | 这个写缓存的方式，本身就是错误的，需要改为先写数据库，把旧缓存置为失效；读取数据的时候，如果缓存不存在，则读取数据库再写缓存 |
| 先写数据库，再写缓存，数据库写成功，缓存写失败 | 写数据库成功，但写缓存失败，则下次读取（并发读）缓存时，则读不到数据 | 缓存使用时，假如读缓存失败，先读数据库，再回写缓存的方式实现 |
| 需要缓存异步刷新 | 指数据库操作和写缓存不在一个操作步骤中，比如在分布式场景下，无法做到同时写缓存或需要异步刷新（补救措施）时候 | 确定哪些数据适合此类场景，根据经验值确定合理的数据不一致时间，用户数据刷新的时间间隔 |

## 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
使用keys指令可以扫出指定模式的key列表。

对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？

这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。