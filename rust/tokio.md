# [零成本抽象](https://tokio-zh.github.io/document/#%E9%9B%B6%E6%88%90%E6%9C%AC%E6%8A%BD%E8%B1%A1)
Tokio以Future为基础。Future不是一个新主意，但Tokio使用它们的方式是独一无二的。与其他语言的Future不同，Tokio的Future编译成状态机。用Future实现常见的同步，分配或其他不会增加额外开销成本。

请注意，提供零成本抽象并不意味着Tokio本身没有成本。这意味着使用Tokio导致最终产品具有与不使用Tokio相同的开销。

## 并发
开箱即用，Tokio提供了一个多线程，工作窃取的调度程序。因此，当您使用tokio :: run开始使用应用程序时，您已经在使用所有计算机的CPU内核。

现代计算机通过添加内核来提高其性能，因此能够利用多个内核对于编写快速应用程序至关重要。
## 非阻塞I/O
当访问网络时，Tokio将使用操作系统可用的最有效系统。在Linux上，这意味着epoll，* bsd平台提供kqueue，Windows具有I / O完成端口。

这允许在单个线程上多路复用许多套接字并批量接收操作系统通知，从而减少系统调用。所有这些都可以减少应用程序的开销。
## 任务 
在tokio中，创建一个任务只需要64bytes，非常轻

### tokio的Mutex和std的Mutex有什么区别？
tokio::sync::Mutex和std::sync::Mutex都提供了互斥锁的功能，但它们在处理阻塞时有所不同。

std::sync::Mutex来自于Rust的标准库，当一个线程试图获取已经被另一个线程持有的锁时，它会阻塞当前线程，直到锁被释放。这对于同步编程来说是可以接受的，但在异步编程中，阻塞一个任务会阻止整个线程的执行，这会导致性能问题。

tokio::sync::Mutex是为异步编程设计的。当一个任务试图获取已经被另一个任务持有的锁时，它不会阻塞整个线程，而是只阻塞当前任务，其他任务可以继续在同一个线程上执行。这使得tokio::sync::Mutex更适合于异步编程环境。

在使用 Tokio 编写异步代码时，一个常见的错误无条件地使用 tokio::sync::Mutex ，而真相是：Tokio 提供的异步锁只应该在跨多个 .await调用时使用，而且 Tokio 的 Mutex 实际上内部使用的也是 std::sync::Mutex。

多补充几句，在异步代码中，关于锁的使用有以下经验之谈：

- 锁如果在多个 .await 过程中持有，应该使用 Tokio 提供的锁，原因是 .await的过程中锁可能在线程间转移，若使用标准库的同步锁存在死锁的可能性，例如某个任务刚获取完锁，还没使用完就因为 .await 让出了当前线程的所有权，结果下个任务又去获取了锁，造成死锁
- 锁竞争不多的情况下，使用 std::sync::Mutex
- 锁竞争多，可以考虑使用三方库提供的性能更高的锁，例如 parking_lot::Mutex
  
当同步锁的竞争变成一个问题时，使用 Tokio 提供的异步锁几乎并不能帮你解决问题，此时可以考虑如下选项：

- 创建专门的任务并使用消息传递的方式来管理状态
- 将锁进行分片  //比如可以将存储分成 3 个实例，那么第一个实例可以存储 a-c，第二个d-f，以此类推。在这种情况下，访问 b 时，只需要锁住第一个实例，此时二、三实例依然可以正常访问，因此锁被成功的分片了。
- 重构代码以避免锁

### Copy和Clone的区别
Copy是一个标记trait，它表示一个类型的值可以通过简单的位复制来复制。当一个类型实现了Copy，那么在赋值或者函数调用时，Rust会自动复制这个类型的值，而不是移动。这意味着原始值仍然可以使用。基本类型（如i32，f64等）和由这些类型组成的复合类型（如元组和数组）都实现了Copy。
```rust
let x = 5;
let y = x; // x is copied, not moved. x can still be used here.
x += 1;//对的
```

Clone是一个功能trait，它表示一个类型的值可以通过调用clone方法来复制。clone方法可能会进行一些复杂的操作，比如分配内存。当一个类型实现了Clone，那么你可以显式地调用clone方法来复制它的值。
```rust
let x = vec![1, 2, 3];
let y = x.clone(); // x is cloned, not moved. x can still be used here.
```
所有实现了Copy的类型也都实现了Clone，但反过来则不成立。一些复杂的类型，如String和Vec<T>，只实现了Clone，而没有实现Copy，因为复制这些类型的值可能会涉及到内存分配等操作。

### Tokio的消息通道（channel）
Tokio 提供了多种消息通道，可以满足不同场景的需求:

- mpsc, 多生产者，单消费者模式
- oneshot, 单生产者，单消费者，一次只能发送一条消息
  > oneshot发送消息不需要.await，因为它要么直接成功，要么直接失败，无需等待
- broadcast，多生产者，多消费者，其中每一条发送的消息都可以被所有接收者收到，因此是广播
- watch，单生产者，多消费者，只保存一条最新的消息，因此接收者只能看到最近的一条消息，例如，这种模式适用于配置文件变化的监听
细心的同学可能会发现，这里还少了一种类型：多生产者、多消费者，且每一条消息只能被其中一个消费者接收，如果有这种需求，可以使用 async-channel 包。

以上这些消息通道都有一个共同点：适用于 async 编程，对于其它场景，你可以使用在多线程章节中提到过的 std::sync::mpsc 和 crossbeam::channel， 这些通道在等待消息时会阻塞当前的线程，因此不适用于 async 编程。
